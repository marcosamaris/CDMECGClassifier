devlist <- dev.list()
devcur <- match(device, devlist, NA)
if (is.na(devcur))
stop(Rtxt("No such device."))
devname <- names(devlist)[devcur]
#if (devname != "windows")
#  stop("can only copy from 'windows' devices")
if (filename == "clipboard" && type == "wmf")
filename <- ""
if (nchar(filename) > 0)
filename <- paste(filename, type, sep = ".")
invisible(.External("savePlot", device, filename, type, restoreConsole,
PACKAGE = "grDevices"))
}
########################################################################
genPlotTitleCmd <- function(..., vector=FALSE)
{
# 080817 Use month name rather than number - less ambiguous.
if (! exists("crv"))
{
crv <- list()
crv$appname <- "Rattle"
crv$verbose <- TRUE
crv$show.timestamp <- TRUE
}
main = paste(...)
if(vector)
{
if (! crv$verbose)
sub <- ""
else if (crv$show.timestamp)
sub <- sprintf("%s %s %s", crv$appname,
format(Sys.time(), "%Y-%b-%d %H:%M:%S"), Sys.info()["user"])
else
sub <- sprintf(Rtxt("Generated by %s"), crv$appname)
return(c(main, sub))
}
else
{
if (! crv$verbose)
sub <- ""
else if (crv$show.timestamp)
sub <- sprintf(paste('paste("%s", format(Sys.time(),',
'"%%Y-%%b-%%d %%H:%%M:%%S"), Sys.info()["user"])'),
crv$appname)
else
sub <- sprintf('paste("%s")', sprintf(Rtxt("Generated by %s"), crv$appname))
return(sprintf('title(main="%s",\n    sub=%s)', main, sub))
}
}
set.cursor <- function(cursor="left-ptr", message=NULL)
{
if (! is.null(message)) setStatusBar(message)
theWidget("rattle_window")$getWindow()$
setCursor(gdkCursorNew(cursor))
# 091106 For now, set cursor specifically on the textview
# windows. Under Ubuntu it is not needed, but is on Vista. Is this a
# GTK+ issue?emove this once MS/Windows no longer has this problem.
# 091106 The first approach, lapply, did not work! Whlist all the
# textview widgets do exist, the getWind0w returned NULL unless the
# textview had been visited. So, instead, loop through the
# textviews.
# lapply(allTextviews(), function(x) theWidget(x)$
#            getWindow("GTK_TEXT_WINDOW_TEXT")$
#            setCursor(gdkCursorNew(cursor)))
for (tv in allTextviews())
{
win <- theWidget(tv)$getWindow("GTK_TEXT_WINDOW_TEXT")
if (! is.null(win)) win$setCursor(gdkCursorNew(cursor))
}
}
simplifyNumberList <- function(nums)
{
## Convert 3 4 6 7 8 9 10 12 14 16 17 18 19 21 to
## "3:4, 6:10, 12, 14, 16:19, 21"
if (length(nums) == 1)
return(sprintf("%s", nums))
else if (is.null(nums) || length(nums) == 0)
return(NULL)
result <- ""
start <- nums[1]
len <- 1
for (i in 2:length(nums))
{
if (nums[i] != start + len)
{
if (len == 1)
result <- sprintf("%s, %d", result, start)
else
result <- sprintf("%s, %d:%d", result, start, nums[i-1])
start <- nums[i]
len <- 1
}
else
len <- len + 1
}
if (len == 1)
result <- sprintf("%s, %d", result, start)
else
result <- sprintf("%s, %d:%d", result, start, nums[i])
result <- sub('c\\(, ', 'c(', sprintf("c(%s)", result))
return(result)
}
get.extension <- function(path)
{
## Extract and return the extension part of a filename
parts <- strsplit(path, "\\.")[[1]]
if (length(parts) > 1)
last <- parts[length(parts)]
else
last <- ""
last
}
get.stem <- function(path)
{
# Given a filename PATH extract the basename, and from this, the
# name without an extension.  090718 If the PATH supplied is a
# string with no extension than just return the PATH.
parts <- strsplit(basename(path), "\\.")[[1]]
if (length(parts) > 1)
last <- paste(parts[seq_len(length(parts)-1)], collapse=".")
else
last <- parts
last
}
plotNetwork <- function(flow)
{
if (! packageIsAvailable("network", Rtxt("draw the network plot"))) return()
require(network, quietly=TRUE)
flow.net <- network(as.matrix(flow))
# Change the line widths to represent the magnitude of the flow.
# Use a log transform to get integers for the line widths.
flow.log <- log10(flow) # Log 10 to get magnitude
flow.log[flow.log==0] <- 1 # Set any 0's to 1 as the base case
flow.log[flow.log==-Inf] <- 0 # Set resulting -Infinty (log10(0)) values to 0
flow.mag <- round(flow.log) # Round them to
# Add color to indicate the magnitude.  Use heat colours to
# indicate the magnitude of the flow, from yellow to red.
heat <- rev(heat.colors(max(flow.mag)))
flow.col <- flow.mag
for (i in seq_along(heat)) flow.col[flow.col==i] <- heat[i]
flow.col <- sapply(flow.col, as.character)
# Record the magnitude of flow coming into any label and use this to
# scale the entity labels.
entity.sizes <- round(log10(apply(flow, 2, sum)))
entity.sizes[entity.sizes==-Inf] <- 0
entity.sizes <- 1 + entity.sizes-min(entity.sizes)
entity.sizes <- 1 + entity.sizes/max(entity.sizes)
# A warning that "par()$cxy * label.cex" have missmatched
# dimensions. par()$cxy is of length 2? Should be 1?
suppressWarnings(plot(flow.net, displaylabels=TRUE, usecurve=TRUE,
mode="circle",
edge.lwd=flow.mag*1.5, edge.col=flow.col,
label.cex=entity.sizes, label.border=0))
eval(parse(text=genPlotTitleCmd("Network Map of Flows")))
}
########################################################################
#
# Shared callbacks
#
## 100916 Update the list only when Evaluate's R Dataset is toggled on.
## update_comboboxentry_with_dataframes <- function(action, window)
## {
##   # Update a combo box (Evaluate -> Score) with just the available
##   # data frames and matrices.
##   current <- theWidget("data_name_combobox")$getActiveText()
##   dl <- unlist(sapply(ls(sys.frame(0)),
##                       function(x)
##                       {
##                         cmd <- sprintf("is.data.frame(%s)", x)
##                         var <- try(ifelse(eval(parse(text=cmd), sys.frame(0)),
##                                           x, NULL), silent=TRUE)
##                         if (inherits(var, "try-error"))
##                           var <- NULL
##                         return(var)
##                       }))
##   if (not.null(dl))
##   {
##     action$getModel()$clear()
##     lapply(dl, action$appendText)
##     ## Set the selection to that which was already selected, if possible.
##     if (not.null(current) && current %in% dl)
##       action$setActive(which(sapply(dl, function(x) x==current))[1]-1)
##   }
## }
on_rattle_window_delete_event <- function(action, window)
{
if (crv$close %in% c("quit", "ask"))
{
msg <-sprintf(Rtxt("Do you want to terminate %s?"), crv$appname)
if (!questionDialog(msg))
return(TRUE)
else
if (crv$close == "quit")
quit(save="no")
else
return(FALSE)
}
}
close_rattle <- function(action, window)
{
# 090401 This callback seems to be called after the window is
# destroyed!!!  So the question serves no purpose... Not clear how
# to fix that.
closeRattle()
}
quit_rattle <- function(action, window)
{
# 080815 This function used to return NULL or "yes" and I always
# tested whether it's results was NULL. But why not return a
# logical? Start doing that now, by returning TRUE instead of "yes",
# and look to return FALSE instead of NULL on a negative response to
# the question.
closeRattle(TRUE)
}
closeRattle <- function(ask=FALSE)
{
if (ask || crv$close %in% c("quit", "ask"))
{
msg <- sprintf(Rtxt("Do you want to terminate %s?"), crv$appname)
if (!questionDialog(msg)) return(FALSE)
}
# Don't remove the graphics for now. In moving to the Cairo device,
# this blanks the device, but does not destroy the containing
# window. I wonder if there is some way to get a list of the plot
# windows, and destroy each one?
# graphics.off() # for (i in dev.list()) dev.off(i)
# 080523 When this is called as a callback from the destroy signal
# of the GtkObject, the window has already been destroyed, so no
# need to try again.
rw <- theWidget("rattle_window")
if (not.null(rw)) rw$destroy()
# Communicate to R that Rattle has finished. This is used by the
# rattle script on GNU/Linux using the littler package which allows
# one to use R as a scripting language. But rattle dispatches
# itself from R, and so normally the script immediately
# terminates. Instead we can have a loop that checks if rattleGUI
# is NULL, and when it is we finish! Seems to work.
rattleGUI <<- NULL
# 080511 Restore options to how they were when Rattle was started.
options(crv$options)
# if (crv$tooltiphack) gtkMainQuit() # Only needed if gtkMain is run.
# 080906 Deal with R not finishing up when rattle is called from
# littler or R CMD BATCH and we close rather than quit.
if (crv$close == "quit") quit(save="no")
}
interrupt_rattle <- function(action, window)
{
# The multicore or fork packages may provide some hope under
# GNU/Linux, but not MS/Wdinwos. Under MS the Esc seems to send a
# SIGBREAK to the R process. How to do that?
infoDialog(Rtxt("This operation is not yet functional."))
}
########################################################################
## General Menu Callbacks
on_rattle_menu_activate <- function(action, window)
{
browseURL("http://rattle.togaware.com")
}
on_delete_menu_activate <- notImplemented
## Map the unchanged glade defaults
on_cut1_activate <- notImplemented
on_about_menu_activate <-  function(action, window)
{
result <- try(etc <- file.path(.path.package(package="rattle")[1], "etc"),
silent=TRUE)
if (crv$useGtkBuilder)
{
about <<- gtkBuilderNew()
about$setTranslationDomain("R-rattle")
}
if (inherits(result, "try-error"))
if (crv$useGtkBuilder)
about$addFromFile("rattle.ui")
else
about <- gladeXMLNew("rattle.glade", root="aboutdialog", domain="R-rattle")
else
if (crv$useGtkBuilder)
about$addFromFile(file.path(etc, "rattle.ui"))
else
about <- gladeXMLNew(file.path(etc, "rattle.glade"),
root="aboutdialog", domain="R-rattle")
if (crv$useGtkBuilder)
{
ab <- about$getObject("aboutdialog")
ab$show()
}
else
ab <- about$getWidget("aboutdialog")
ab$setVersion(crv$version)
configureAbout(ab)
if (crv$useGtkBuilder)
about$connectSignals()
else
gladeXMLSignalAutoconnect(about)
}
configureAbout <- function(ab)
{
ab["program-name"] <- "Rattle"
ab$setCopyright(paste(VERSION.DATE, "\n\n", COPYRIGHT, "\n" ,
Rtxt("All rights reserved.")))
}
on_paste1_activate <- notImplemented
on_copy1_activate <- notImplemented
on_tooltips_activate <- function(action, window)
{
## infoDialog("Currently this functionality is not implemented.",
##             "It is awaiting some insight into how to get hold of",
##             "the glade GtkTooltips group, which can then be",
##             "disabled or enabled as requested.")
if(action$getActive())
{
myWin <- theWidget("rattle_window")
myWin$addEvents(GdkEventMask["focus-change-mask"])
gSignalConnect(myWin, "focus-in-event", gtkmain_handler)
gSignalConnect(myWin, "focus-out-event", gtkmainquit_handler)
gSignalConnect(myWin, "delete-event", gtkmainquit_handler)
}
## else
## {
##   infoDialog("Currently the functionality to turn tooltips off",
##              "is not implemented.")
## }
}
on_verbose_menuitem_toggled <- function(action, window)
{
crv$verbose <- theWidget("verbose_menuitem")$getActive()
}
##----------------------------------------------------------------------
## Miscellaneous callbacks
on_notebook_switch_page <- function(notebook, window, page)
{
## notebook is the GtkNotebook object.
## window is ??.
## page is the index of the page switched to.
#ct <- current_(page)
switchToPage(page)
}
on_tools_data_activate <- function(action, window)
{
crv$NOTEBOOK$setCurrentPage(getNotebookPage(crv$NOTEBOOK,
crv$NOTEBOOK.DATA.NAME))
switchToPage(crv$NOTEBOOK.DATA.NAME)
}
on_tools_test_activate <- function(action, window)
{
crv$NOTEBOOK$setCurrentPage(getNotebookPage(crv$NOTEBOOK,
crv$NOTEBOOK.TEST.NAME))
switchToPage(crv$NOTEBOOK.TEST.NAME)
}
on_tools_transform_activate <- function(action, window)
{
crv$NOTEBOOK$setCurrentPage(getNotebookPage(crv$NOTEBOOK,
crv$NOTEBOOK.TRANSFORM.NAME))
switchToPage(crv$NOTEBOOK.TRANSFORM.NAME)
}
on_tools_explore_activate <- function(action, window)
{
crv$NOTEBOOK$setCurrentPage(getNotebookPage(crv$NOTEBOOK,
crv$NOTEBOOK.EXPLORE.NAME))
switchToPage(crv$NOTEBOOK.EXPLORE.NAME)
}
on_tools_cluster_activate <- function(action, window)
{
crv$NOTEBOOK$setCurrentPage(getNotebookPage(crv$NOTEBOOK,
crv$NOTEBOOK.CLUSTER.NAME))
switchToPage(crv$NOTEBOOK.CLUSTER.NAME)
}
on_tools_model_activate <- function(action, window)
{
crv$NOTEBOOK$setCurrentPage(getNotebookPage(crv$NOTEBOOK,
crv$NOTEBOOK.MODEL.NAME))
switchToPage(crv$NOTEBOOK.MODEL.NAME)
}
on_tools_evaluate_activate <- function(action, window)
{
crv$NOTEBOOK$setCurrentPage(getNotebookPage(crv$NOTEBOOK,
crv$NOTEBOOK.EVALUATE.NAME))
switchToPage(crv$NOTEBOOK.EVALUATE.NAME)
}
on_tools_log_activate <- function(action, window)
{
crv$NOTEBOOK$setCurrentPage(getNotebookPage(crv$NOTEBOOK,
crv$NOTEBOOK.LOG.NAME))
switchToPage(crv$NOTEBOOK.LOG.NAME)
}
switchToPage <- function(page)
{
# Blank the status bar whenever we change pages
setStatusBar()
# This function used to accept numeric pages, so check for that and
# convert to the page name rather than the now changing page number
# (page numbers used to be fixed).
if (is.numeric(page))
page <- getNotebookPageLabel(crv$NOTEBOOK, page)
# 091112 This is now done in configureEvaluateTab.
## if (page == crv$NOTEBOOK.EVALUATE.NAME)
## {
##   # On moving to the EVALUATE page, ensure each built model's
##   # checkbox is active, and check the active model's checkbox, but
##   # leave all the other as they are.
##   mtypes <- listBuiltModels(exclude=crv$APRIORI)
##   if (not.null(mtypes))
##   {
##     # We have some models, so make sure their checkboxes are
##     # sensitive.
##     lapply(mtypes,
##            function(x) theWidget(paste(x, "_evaluate_checkbutton",
##                                           sep=""))$setSensitive(TRUE))
##     if (is.null(crs$page) || crs$page == crv$NOTEBOOK.MODEL.NAME)
##     {
##       # By default check the current model's check button if we
##       # have just come from the MODEL page. This makes it easy when
##       # swaping from the Model page to this page to evaluate the
##       # just built model (usually). The NULL test on crs$page
##       # simply covers the loading of a project that did not save
##       # the crs$page, as was the case for old project files.
##       if (currentModelTab() %in% mtypes)
##         theWidget(paste(currentModelTab(), "_evaluate_checkbutton",
##                         sep=""))$setActive(TRUE)
##     }
##   }
## }
# When changing to the LOG page desensitise the Execute button. Not
# sure why anyone would push the execute button anyhow, so maybe
# this is just better to result in an errorDialog rather than extra
# logic here to greyt out the button?
if (page == crv$NOTEBOOK.LOG.NAME)
{
theWidget("execute_button")$setSensitive(FALSE)
theWidget("execute_menu")$setSensitive(FALSE)
}
else
{
theWidget("execute_button")$setSensitive(TRUE)
theWidget("execute_menu")$setSensitive(TRUE)
}
# Record the current page so when we change we know which was last.
crs$page <- page
}
fix(rattle)
rattle()
install.packages('RGtk2')
install.packages('RGtk2')
library("rattle")
load("~/Dropbox/MS-Tesis/datas.RData")
## visualize the result
par(mfrow=c(1,1))
plot(seq(from=0,to=12,by=1/250)[1:3000],
ecgSanosF$"s-1006BR"[1:3000],type="l")
points((seq.int(from=0,to=12,by=1/250))[maxminSanos$"s-1006BR"$index.max],
(ecgInfartosF$"s-1006BR")[1:3000][maxminSanos$"s-1006BR"$index.max],
col=2, pch=1)
par(mfrow=c(1,1))
plot(seq(from=0,to=12,by=1/250)[1:3000],
ecgSanosF$"s-1006BR"[1:3000],type="l")
points((seq.int(from=0,to=12,by=1/250))[maxminSanos$"s-1006BR"$index.max],
(ecgInfartosF$"s-1006BR")[1:3000][maxminSanos$"s-1006BR"$index.max],
col=2, pch=1)
par(mfrow=c(1,1))
plot(seq(from=0,to=12,by=1/250)[1:3000],
ecgSanosF$"s-1006BR"[1:3000],type="l")
points((seq.int(from=0,to=12,by=1/250))[1:3000][maxminSanos$"s-1006BR"$index.max],
(ecgInfartosF$"s-1006BR")[1:3000][maxminSanos$"s-1006BR"$index.max],
col=2, pch=1)
load("~/Dropbox/MS-Tesis/Source/datas_1.RData")
load("~/Dropbox/MS-Tesis/Source/datas_1.RData")
setwd('~/Dropbox/MS-Tesis/Source/')
library("msProcess")
library("svWidgets")
library("rpanel")
source("./PAA_SAX.R")
source("./Cargar_DB.R")
source("./PreProc.R")
source("./Transform.R")
source("./Clasific.R")
source("./Graphics.R")
source("./Rpanel-Visual.R")
FiltrarMuestras()
DetectarR()
HRV()
maxInfartos
DetectarR()
DetectarR()
DetectarR <- function() {
# detect local maxima and minima
maxInfartos <<- lapply(ecgInfartosF, msExtrema,span=200)
maxSanos <<- lapply(ecgSanosF, msExtrema,span=200)
}
DetectarR()
write((seq.int(from=0,to=300,by=1/250))[1:75000][maxInfartos$"10071286-1"$index.max], file="Temp.txt",ncolumns=1)
temp <- LoadBeatAscii(temp,FileName="./Temp.txt",verbose=TRUE)
temp <- CreateFreqAnalysis(HRVData=temp,verbose=TRUE)
library("RHRV")
temp <- CreateTimeAnalysis(HRVData=temp,size=300,numofbins=20,interval=7.8125,verbose=TRUE)
temp <- BuildNIHR(temp, verbose=TRUE)
temp <- BuildNIHR(temp, verbose=TRUE)
temp <- LoadBeatAscii(temp,FileName="./Temp.txt",verbose=TRUE)
write((seq.int(from=0,to=300,by=1/250))[1:75000][maxInfartos$"10071286-1"$index.max], file="Temp.txt",ncolumns=1)
temp <- LoadBeatAscii(temp,FileName="./Temp.txt",verbose=TRUE)
temp <- CreateHRVData(Verbose=TRUE)
write((seq.int(from=0,to=300,by=1/250))[1:75000][maxInfartos$"10071286-1"$index.max], file="Temp.txt",ncolumns=1)
temp <- LoadBeatAscii(temp,FileName="./Temp.txt",verbose=TRUE)
temp <- BuildNIHR(temp, verbose=TRUE)
temp <- CreateFreqAnalysis(HRVData=temp,verbose=TRUE)
temp <- CreateNonLinearAnalysis(HRVData=temp,verbose=TRUE)
temp <- CreateTimeAnalysis(HRVData=temp,size=300,numofbins=20,interval=7.8125,verbose=TRUE)
WriteToFile(HRVData=temp, "Temp.txt", overwrite = TRUE, verbose=TRUE)
WriteToFile(HRVData=temp, "Temp.txt", overwrite = TRUE, verbose=TRUE)
temp <- CreateTimeAnalysis(HRVData=temp,size=300,numofbins=20,interval=7.8125,verbose=TRUE)
load("~/Dropbox/MS-Tesis/Source/datas-1.RData")
library("maxLik")
